#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Written for python 3, not tested under 2.
"""
"""
__author__ = "Matteo Ferla. [Github](https://github.com/matteoferla)"
__email__ = "matteo.ferla@gmail.com"
__date__ = ""

N = "\n"
T = "\t"
# N = "<br/>


def obsolete_driver(lsize, seq_len, lambda_cross, positions, observable=True):
    """
    Given a library of L sequences generated by random recombination
    of two near-identical genes differing at only a small number of known nucleotide (or amino acid) positions,
    we wish to calculate the expected number of distinct sequences in the library.
    (Typically assuming the mean number of crossovers per sequence m < 0.1 x sequence length N).
    Even if DRIVeR is a (forced) backronym for Diversity Resulting from In vitro Recombination, this method is in lowercase due to PEP8.
    :param lsize: library size
    :param seq_len: seq length
    :param lambda_cross: mean number of crossovers
    :param positions: list of positions of variable bases (numbered from 1 onwards)
    :param observable: boolean for observable (True) or all (False) crossovers
    :return: number of possible seqs, expected number of distinct seqs, mean num of actual cross, mean num of obs cross.
    """
    n_mutant = len(positions)
    possible_seq = 2 ** n_mutant
    distances = [zb - za for za, zb in zip(positions, positions[1:])]  # Is this a Perl flashback nostalgia?
    # print(distances)
    # print(sum([positions[0]-1]+distances+[seq_len-positions[-1]]),seq_len-1)
    exponential_factors = [math.exp(-2 * (ni - 1) * lambda_cross / (seq_len - n_mutant - 1)) for ni in distances]
    blist = product(range(2), repeat=n_mutant - 1)
    # print(possible_seq,len(list(blist)))
    bsum_check = 0
    c = 0
    for b in blist:  # b is a tuple of n_mutant zeros..
        bp = 1  # Guido did not add a prod() hence this ugly thing
        for i, bk in enumerate(b[:-1]):
            if bk == 0:
                bp *= 0.5 * (1 - exponential_factors[i])
            elif bk == 1:
                bp *= 0.5 * (1 + exponential_factors[i])
        bsum_check += bp
        c += 1 - (1 - bp / 2) ** lsize
        # print(bsum_check)
    print(c, 'â‰ ', 67.96)
    warn('lambda_cross obs maths not done.')
    raise NotImplementedError


def subdriver(lsize, seq_len, lambda_cross, positions):
    n_mutant = len(positions)
    possible_seq = 2 ** n_mutant
    distances = [zb - za for za, zb in zip(positions, positions[1:])]
    exponential_factors = [math.exp(-2 * (ni - 1) * lambda_cross / (seq_len - n_mutant - 1)) for ni in distances]
    blist = product(range(2), repeat=n_mutant - 1)
    bsum_check = 0
    pk = 0
    for b in blist:  # b is a tuple of n_mutant zeros..
        bp = 1
        for i, bk in enumerate(b[:-1]):
            if bk == 0:
                bp *= 0.5 * (1 - exponential_factors[i])
            elif bk == 1:
                bp *= 0.5 * (1 + exponential_factors[i])
        bsum_check += bp
        pk +=bp*sum(b)
    return pk


if __name__ == "__main__":
    pass